<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fredonia Hub</title>
<link rel="stylesheet" href="styles.css?v=10" />
</head>

<body>
<main class="wrap">

  <div class="brand">The Howard Homestead LLC</div>
  <h1>FREDONIA, PA 16124</h1>

  <!-- ================= TIME + CURRENT ================= -->
  <section class="panel" aria-label="Time and weather">
    <div class="row">

      <div class="block">
        <div class="label">Eastern Standard Time</div>
        <div class="clock" id="clockTime">--:--</div>
        <div class="date" id="clockDate">Loading date…</div>
      </div>

      <div class="block right">
        <div class="label">Current Conditions (16124)</div>

        <div class="condRow" style="display:flex;gap:14px;align-items:flex-start;justify-content:flex-end;flex-wrap:wrap;">
          <img id="condIcon" alt="" style="width:64px;height:64px;object-fit:contain;border:1px solid rgba(212,175,55,.25);" />
          <div>
            <div class="temp" id="tempF">--°F</div>
            <div class="small"><b style="color:#fff;">Conditions:</b> <span id="condText">--</span></div>
            <div class="small"><b style="color:#fff;">Humidity:</b> <span id="rh">--</span>%</div>
            <div class="small"><b style="color:#fff;">Wind:</b> <span id="windNow">--</span></div>
            <div class="small"><b style="color:#fff;">Moon:</b> <span id="moonText">--</span></div>
          </div>
          <img id="moonIcon" alt="" style="width:44px;height:44px;object-fit:contain;opacity:.95;" />
        </div>

        <div class="small" id="tempMeta">Syncing…</div>
      </div>

    </div>

    <div class="small status" id="syncStatus">Syncing time…</div>
  </section>

  <!-- ================= FORECAST ================= -->
  <section class="panel" aria-label="3-day forecast" style="margin-top:14px;">
    <div class="label">3-Day Forecast</div>
    <div class="forecastGrid" id="forecast3">
      <div class="small">Loading forecast…</div>
    </div>
  </section>

</main>

<script>
(function(){

/* ================= ZIP 16124 COORDS (centroid-ish) ================= */
const LAT = 41.33336;
const LON = -80.26486;

/* ================= DOM ================= */
const timeEl = document.getElementById("clockTime");
const dateEl = document.getElementById("clockDate");
const syncEl = document.getElementById("syncStatus");

const tempEl = document.getElementById("tempF");
const metaEl = document.getElementById("tempMeta");
const rhEl = document.getElementById("rh");
const windEl = document.getElementById("windNow");
const condEl = document.getElementById("condText");
const condIconEl = document.getElementById("condIcon");
const moonTextEl = document.getElementById("moonText");
const moonIconEl = document.getElementById("moonIcon");

const forecastWrap = document.getElementById("forecast3");

/* ================= CLOCK (internet-synced offset) ================= */
let offsetMs = 0;
let lastTimeSync = 0;

function formatTime(d){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    hour:"numeric",
    minute:"2-digit",
    hour12:true
  }).format(d);
}

function formatDate(d){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    weekday:"long",
    year:"numeric",
    month:"long",
    day:"numeric"
  }).format(d);
}

function renderTime(){
  const now = new Date(Date.now() + offsetMs);
  timeEl.textContent = formatTime(now);
  dateEl.textContent = formatDate(now);

  if(lastTimeSync){
    const age = Math.floor((Date.now()-lastTimeSync)/1000);
    syncEl.textContent = "Time synced " + age + "s ago";
  }
}

async function syncTime(){
  try{
    const r = await fetch("https://time.now/developer/api/timezone/America/New_York",{cache:"no-store"});
    if(!r.ok) throw new Error("time.now HTTP " + r.status);
    const j = await r.json();
    if(typeof j.unixtime !== "number") throw new Error("Bad time payload");
    offsetMs = (j.unixtime * 1000) - Date.now();
    lastTimeSync = Date.now();
  }catch(e){
    offsetMs = 0;
    syncEl.textContent = "Time sync failed (device time)";
  }
}

/* ================= MOON (local calc + base64 SVG) ================= */
function approxMoonPhase01(date){
  // New moon reference: 2000-01-06 18:14 UTC (common anchor)
  const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14, 0);
  const synodicMs = 29.530588853 * 24 * 60 * 60 * 1000;
  const t = date.getTime() - knownNewMoon;
  let phase = (t % synodicMs) / synodicMs;
  if (phase < 0) phase += 1;
  return phase; // 0=new, 0.5=full
}

function moonPhaseName(phase){
  const p = Number(phase);
  if(p < 0.03 || p > 0.97) return "New Moon";
  if(p < 0.22) return "Waxing Crescent";
  if(p < 0.28) return "First Quarter";
  if(p < 0.47) return "Waxing Gibbous";
  if(p < 0.53) return "Full Moon";
  if(p < 0.72) return "Waning Gibbous";
  if(p < 0.78) return "Last Quarter";
  return "Waning Crescent";
}

function moonSvgBase64(phase){
  const p = Number(phase);
  const shift = Math.cos(2*Math.PI*p); // +1 new, -1 full
  const cx = 50 + (shift * 22);

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <mask id="m">
      <rect width="100" height="100" fill="black"/>
      <circle cx="50" cy="50" r="38" fill="white"/>
      <circle cx="${cx.toFixed(2)}" cy="50" r="38" fill="black"/>
    </mask>
  </defs>
  <circle cx="50" cy="50" r="38" fill="white" opacity="0.18"/>
  <circle cx="50" cy="50" r="38" fill="white" mask="url(#m)"/>
</svg>`;

  const b64 = btoa(unescape(encodeURIComponent(svg)));
  return "data:image/svg+xml;base64," + b64;
}

function renderMoon(){
  const phase = approxMoonPhase01(new Date());
  moonTextEl.textContent = moonPhaseName(phase);
  moonIconEl.src = moonSvgBase64(phase);
}

/* ================= WEATHER (NWS current + forecast + gusts) ================= */
function degToCardinal(deg){
  if (deg === null || deg === undefined || Number.isNaN(deg)) return "—";
  const dirs=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
  return dirs[Math.round(deg/22.5)%16];
}

async function fetchGeo(url){
  const r = await fetch(url,{cache:"no-store", headers:{Accept:"application/geo+json"}});
  if(!r.ok) throw new Error("HTTP " + r.status);
  return r.json();
}

function dayKeyNY(date){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    year:"numeric",month:"2-digit",day:"2-digit"
  }).format(date);
}

function toMphFrom(uom,value){
  if(value===null||value===undefined||Number.isNaN(value)) return null;
  const s=String(uom||"");
  if(s.includes("knots")) return value*1.15078;
  if(s.includes("m_s-1")) return value*2.23694;
  if(s.includes("mph")) return value;
  return value;
}

function windStr(dir, speed){
  const d = dir ? String(dir).trim() : "";
  const s = speed ? String(speed).trim() : "";
  return (d || s) ? `${d} ${s}`.trim() : "—";
}

async function syncCurrentNWS(){
  try{
    const point = await fetchGeo(`https://api.weather.gov/points/${LAT},${LON}`);

    // stations
    const st = await fetchGeo(point.properties.observationStations);
    const firstStation = st?.observationStations?.[0];
    if(!firstStation) throw new Error("No NWS station found");

    // latest observation
    const obs = await fetchGeo(firstStation + "/observations/latest");
    const o = obs.properties || {};

    // temp: C -> F
    const tC = o?.temperature?.value;
    const tF = (typeof tC==="number") ? (tC*9/5+32) : null;
    tempEl.textContent = (tF!==null) ? (Math.round(tF)+"°F") : "--°F";

    // RH
    const rh = o?.relativeHumidity?.value;
    rhEl.textContent = (typeof rh==="number") ? Math.round(rh) : "--";

    // wind: m/s -> mph
    const ws = o?.windSpeed?.value;
    const mph = (typeof ws==="number") ? (ws*2.23694) : null;
    const wd = o?.windDirection?.value;
    windEl.textContent = (mph!==null && typeof wd==="number") ? `${Math.round(mph)} mph ${degToCardinal(wd)}` : "--";

    // conditions text
    condEl.textContent = o?.textDescription || "—";

    // icon: use first forecast period icon for visuals
    const fc = await fetchGeo(point.properties.forecast);
    const period0 = fc?.properties?.periods?.[0];
    if(period0?.icon) condIconEl.src = period0.icon;

    metaEl.textContent = "Synced (NWS)";
    return point; // return point so forecast can reuse
  }catch(e){
    metaEl.textContent = "Weather failed: " + (e?.message || "unknown");
    throw e;
  }
}

async function syncForecastNWS(point){
  try{
    const forecast = await fetchGeo(point.properties.forecast);
    const grid = await fetchGeo(point.properties.forecastGridData);

    const periods = forecast?.properties?.periods || [];
    if(!periods.length) throw new Error("No forecast periods");

    const now = new Date();
    const dayMap = new Map(); // dayKey -> {day,night}
    for(const p of periods){
      const start = new Date(p.startTime);
      if(start < now) continue;

      const k = dayKeyNY(start);
      if(!dayMap.has(k)) dayMap.set(k,{day:null,night:null});
      const entry = dayMap.get(k);

      if(p.isDaytime && !entry.day) entry.day = p;
      if(!p.isDaytime && !entry.night) entry.night = p;

      if(dayMap.size >= 3){
        const first3 = Array.from(dayMap.entries()).slice(0,3);
        if(first3.every(([_,e]) => e.day || e.night)) break;
      }
    }
    const first3 = Array.from(dayMap.entries()).slice(0,3);

    // gusts per day (max)
    const gustSeries = grid?.properties?.windGust?.values || [];
    const gustUom = grid?.properties?.windGust?.uom || "";
    const gustMaxByDay = new Map();

    for(const v of gustSeries){
      const startISO = v.validTime.split("/")[0];
      const start = new Date(startISO);
      if(start < now) continue;

      const k = dayKeyNY(start);
      if(!first3.find(([key])=>key===k)) continue;

      const raw = (typeof v.value==="number") ? v.value : null;
      if(raw===null) continue;

      const mph = toMphFrom(gustUom, raw);
      const prev = gustMaxByDay.get(k);
      gustMaxByDay.set(k, (prev===undefined) ? mph : Math.max(prev, mph));
    }

    forecastWrap.innerHTML = "";
    for(const [k,entry] of first3){
      const d = entry.day;
      const n = entry.night;

      const hi = (d && typeof d.temperature==="number") ? `${d.temperature}°F` : "—";
      const lo = (n && typeof n.temperature==="number") ? `${n.temperature}°F` : "—";
      const icon = (d&&d.icon) || (n&&n.icon) || "";
      const name = (d&&d.name) || (n&&n.name) || "Forecast";

      const popVal = (d?.probabilityOfPrecipitation?.value ?? n?.probabilityOfPrecipitation?.value);
      const popText = (typeof popVal==="number") ? `${Math.round(popVal)}%` : "—";

      const windDir = d?.windDirection ?? n?.windDirection;
      const windSpd = d?.windSpeed ?? n?.windSpeed;

      const gust = gustMaxByDay.get(k);
      const gustText = (typeof gust==="number") ? `${Math.round(gust)} mph` : "—";

      forecastWrap.insertAdjacentHTML("beforeend",`
        <div class="fcard">
          <div class="fday">${name}</div>
          <div class="frow">
            ${icon ? `<img class="ficon" src="${icon}" alt="">` : ``}
            <div class="fmeta">
              <div class="fhilow"><b>Hi:</b> ${hi} &nbsp; <b>Lo:</b> ${lo}</div>
              <div><b>PoP:</b> ${popText}</div>
              <div><b>Wind:</b> ${windStr(windDir, windSpd)}</div>
              <div><b>Gusts:</b> ${gustText}</div>
            </div>
          </div>
        </div>
      `);
    }
  }catch(e){
    forecastWrap.innerHTML = '<div class="small">Forecast failed: '+ (e?.message || "unknown") +'</div>';
  }
}

/* ================= RUN ================= */
syncTime().finally(()=>{
  renderTime();
  setInterval(renderTime, 1000);
  setInterval(syncTime, 10*60*1000);
});

renderMoon();
setInterval(renderMoon, 60*60*1000); // update moon hourly

(async ()=>{
  try{
    const point = await syncCurrentNWS();
    await syncForecastNWS(point);
  }catch(e){
    // current already shows error in meta line
  }
})();

setInterval(async ()=>{
  try{
    const point = await syncCurrentNWS();
    await syncForecastNWS(point);
  }catch(e){}
}, 30*60*1000);

})();
</script>

</body>
</html>
