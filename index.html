<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fredonia Hub</title>
<link rel="stylesheet" href="styles.css" />
</head>

<body>
<main class="wrap">

<div class="brand">The Howard Homestead LLC</div>
<h1>FREDONIA, PA 16124</h1>

<!-- ================= TIME + TEMP ================= -->
<section class="panel" aria-label="Time and weather">
<div class="row">

<div class="block">
<div class="label">Eastern Standard Time</div>
<div class="clock" id="clockTime">--:--</div>
<div class="date" id="clockDate">Loading date…</div>
</div>

<div class="block right">
<div class="label">Current Temp (16124)</div>
<div class="temp" id="tempF">--°F</div>
<div class="small" id="tempMeta">Syncing…</div>
</div>

</div>
<div class="small status" id="syncStatus">Syncing time…</div>
</section>

<!-- ================= FORECAST ================= -->
<section class="panel" aria-label="3-day forecast">
<div class="label">3-Day Forecast</div>
<div class="forecastGrid" id="forecast3">
<div class="small">Loading forecast…</div>
</div>
</section>

</main>

<script>
(function(){

/* ================= CLOCK ================= */
const timeEl = document.getElementById("clockTime");
const dateEl = document.getElementById("clockDate");
const syncEl = document.getElementById("syncStatus");

let offsetMs = 0;
let lastTimeSync = 0;

function formatTime(d){
return new Intl.DateTimeFormat("en-US",{
timeZone:"America/New_York",
hour:"2-digit",
minute:"2-digit",
hour12:false
}).format(d);
}

function formatDate(d){
return new Intl.DateTimeFormat("en-US",{
timeZone:"America/New_York",
weekday:"long",
year:"numeric",
month:"long",
day:"numeric"
}).format(d);
}

function renderTime(){
const now=new Date(Date.now()+offsetMs);
timeEl.textContent=formatTime(now);
dateEl.textContent=formatDate(now);

if(lastTimeSync){
const age=Math.floor((Date.now()-lastTimeSync)/1000);
syncEl.textContent="Time synced "+age+"s ago";
}
}

async function syncTime(){
try{
const r=await fetch("https://time.now/developer/api/timezone/America/New_York",{cache:"no-store"});
const j=await r.json();
offsetMs=(j.unixtime*1000)-Date.now();
lastTimeSync=Date.now();
}catch{
offsetMs=0;
syncEl.textContent="Time sync failed (device time)";
}
}

/* ================= TEMP ================= */
const tempEl=document.getElementById("tempF");
const tempMetaEl=document.getElementById("tempMeta");

let cachedLat=null;
let cachedLon=null;

async function geocodeZip(){
const r=await fetch("https://geocoding-api.open-meteo.com/v1/search?name=16124&count=1&country=US");
const j=await r.json();
const loc=j.results[0];
cachedLat=loc.latitude;
cachedLon=loc.longitude;
}

async function syncTemp(){
try{
if(cachedLat===null) await geocodeZip();

const r=await fetch(
`https://api.open-meteo.com/v1/forecast?latitude=${cachedLat}&longitude=${cachedLon}&current=temperature_2m&temperature_unit=fahrenheit&timezone=America%2FNew_York`
);

const j=await r.json();
tempEl.textContent=Math.round(j.current.temperature_2m)+"°F";
tempMetaEl.textContent="Synced";
}catch{
tempMetaEl.textContent="Temp sync failed";
}
}

/* ================= FORECAST ================= */
const forecastWrap=document.getElementById("forecast3");

function windStr(d,s){
return ((d||"")+" "+(s||"")).trim()||"—";
}

async function fetchJSON(url){
const r=await fetch(url,{headers:{Accept:"application/geo+json"}});
return r.json();
}

function dayKeyNY(date){
return new Intl.DateTimeFormat("en-US",{
timeZone:"America/New_York",
year:"numeric",
month:"2-digit",
day:"2-digit"
}).format(date);
}

async function syncForecast(){
try{

if(cachedLat===null) await geocodeZip();

const point=await fetchJSON(`https://api.weather.gov/points/${cachedLat},${cachedLon}`);
const forecast=await fetchJSON(point.properties.forecast);

const periods=forecast.properties.periods;
const days=new Map();
const now=new Date();

for(const p of periods){
const start=new Date(p.startTime);
if(start<now) continue;

const k=dayKeyNY(start);

if(!days.has(k)) days.set(k,{day:null,night:null});

const entry=days.get(k);
if(p.isDaytime && !entry.day) entry.day=p;
if(!p.isDaytime && !entry.night) entry.night=p;

if(days.size>=3 && entry.day && entry.night) break;
}

forecastWrap.innerHTML="";

Array.from(days.entries()).slice(0,3).forEach(([k,entry])=>{

const d=entry.day;
const n=entry.night;

const hi=d?`${d.temperature}°F`:"—";
const lo=n?`${n.temperature}°F`:"—";

const icon=(d&&d.icon)||(n&&n.icon)||"";
const name=(d&&d.name)||(n&&n.name)||"Forecast";

const pop=(d?.probabilityOfPrecipitation?.value ?? n?.probabilityOfPrecipitation?.value);
const popText=(typeof pop==="number")?pop+"%":"—";

const windDir=d?.windDirection ?? n?.windDirection;
const windSpd=d?.windSpeed ?? n?.windSpeed;

forecastWrap.insertAdjacentHTML("beforeend",`
<div class="fcard">
<div class="fday">${name}</div>
<div class="frow">
<img class="ficon" src="${icon}" />
<div class="fmeta">
<div class="fhilow"><b>Hi:</b> ${hi} &nbsp; <b>Lo:</b> ${lo}</div>
<div><b>PoP:</b> ${popText}</div>
<div><b>Wind:</b> ${windStr(windDir,windSpd)}</div>
</div>
</div>
</div>
`);
});

}catch{
forecastWrap.innerHTML='<div class="small">Forecast load failed.</div>';
}
}

/* ================= RUN ================= */
syncTime().finally(()=>{
renderTime();
setInterval(renderTime,1000);
setInterval(syncTime,600000);
});

syncTemp();
setInterval(syncTemp,600000);

syncForecast();
setInterval(syncForecast,1800000);

})();
</script>

</body>
</html>
