<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fredonia Hub</title>
<link rel="stylesheet" href="styles.css?v=9" />
</head>

<body>
<main class="wrap">

  <div class="brand">The Howard Homestead LLC</div>
  <h1>FREDONIA, PA 16124</h1>

  <!-- ================= TIME + CURRENT ================= -->
  <section class="panel" aria-label="Time and weather">
    <div class="row">

      <div class="block">
        <div class="label">Eastern Standard Time</div>
        <div class="clock" id="clockTime">--:--</div>
        <div class="date" id="clockDate">Loading date…</div>
      </div>

      <div class="block right">
        <div class="label">Current Conditions (16124)</div>

        <div class="condRow" style="display:flex;gap:14px;align-items:flex-start;justify-content:flex-end;flex-wrap:wrap;">
          <img id="condIcon" alt="" style="width:64px;height:64px;object-fit:contain;border:1px solid rgba(212,175,55,.25);" />
          <div>
            <div class="temp" id="tempF">--°F</div>
            <div class="small"><b style="color:#fff;">Conditions:</b> <span id="condText">--</span></div>
            <div class="small"><b style="color:#fff;">Humidity:</b> <span id="rh">--</span>%</div>
            <div class="small"><b style="color:#fff;">Wind:</b> <span id="windNow">--</span></div>
            <div class="small"><b style="color:#fff;">Moon:</b> <span id="moonText">--</span></div>
          </div>
          <img id="moonIcon" alt="" style="width:44px;height:44px;object-fit:contain;opacity:.95;" />
        </div>

        <div class="small" id="tempMeta">Syncing…</div>
      </div>

    </div>

    <div class="small status" id="syncStatus">Syncing time…</div>
  </section>

  <!-- ================= FORECAST ================= -->
  <section class="panel" aria-label="3-day forecast" style="margin-top:14px;">
    <div class="label">3-Day Forecast</div>
    <div class="forecastGrid" id="forecast3">
      <div class="small">Loading forecast…</div>
    </div>
  </section>

</main>

<script>
(function(){

/* ================= ZIP 16124 COORDS (no geocode; more reliable) ================= */
const LAT = 41.33336;
const LON = -80.26486;

/* ================= CLOCK ================= */
const timeEl = document.getElementById("clockTime");
const dateEl = document.getElementById("clockDate");
const syncEl = document.getElementById("syncStatus");

let offsetMs = 0;
let lastTimeSync = 0;

function formatTime(d){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    hour:"numeric",
    minute:"2-digit",
    hour12:true
  }).format(d);
}

function formatDate(d){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    weekday:"long",
    year:"numeric",
    month:"long",
    day:"numeric"
  }).format(d);
}

function renderTime(){
  const now = new Date(Date.now() + offsetMs);
  timeEl.textContent = formatTime(now);
  dateEl.textContent = formatDate(now);

  if(lastTimeSync){
    const age = Math.floor((Date.now()-lastTimeSync)/1000);
    syncEl.textContent = "Time synced " + age + "s ago";
  }
}

async function syncTime(){
  try{
    const r = await fetch("https://time.now/developer/api/timezone/America/New_York",{cache:"no-store"});
    if(!r.ok) throw new Error("time.now HTTP " + r.status);
    const j = await r.json();
    if(typeof j.unixtime !== "number") throw new Error("Bad time payload");
    offsetMs = (j.unixtime * 1000) - Date.now();
    lastTimeSync = Date.now();
  }catch(e){
    offsetMs = 0;
    syncEl.textContent = "Time sync failed (device time)";
  }
}

/* ================= HELPERS ================= */

<script>
function approxMoonPhase01(date){
  // Simple synodic cycle approximation: returns 0..1
  // Reference new moon: 2000-01-06 18:14 UTC (common anchor)
  const knownNewMoon = Date.UTC(2000, 0, 6, 18, 14, 0);
  const synodicMs = 29.530588853 * 24 * 60 * 60 * 1000;
  const t = date.getTime() - knownNewMoon;
  let phase = (t % synodicMs) / synodicMs;
  if (phase < 0) phase += 1;
  return phase; // 0=new, 0.5=full
}

function moonPhaseName(phase){
  const p = Number(phase);
  if(p < 0.03 || p > 0.97) return "New Moon";
  if(p < 0.22) return "Waxing Crescent";
  if(p < 0.28) return "First Quarter";
  if(p < 0.47) return "Waxing Gibbous";
  if(p < 0.53) return "Full Moon";
  if(p < 0.72) return "Waning Gibbous";
  if(p < 0.78) return "Last Quarter";
  return "Waning Crescent";
}

function moonSvgBase64(phase){
  // Base64 SVG data URI for maximum compatibility in <img>. :contentReference[oaicite:1]{index=1}
  const p = Number(phase);
  const shift = Math.cos(2*Math.PI*p); // +1 new, -1 full
  const cx = 50 + (shift * 22);

  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <mask id="m">
      <rect width="100" height="100" fill="black"/>
      <circle cx="50" cy="50" r="38" fill="white"/>
      <circle cx="${cx.toFixed(2)}" cy="50" r="38" fill="black"/>
    </mask>
  </defs>
  <circle cx="50" cy="50" r="38" fill="white" opacity="0.18"/>
  <circle cx="50" cy="50" r="38" fill="white" mask="url(#m)"/>
</svg>`;

  const b64 = btoa(unescape(encodeURIComponent(svg)));
  return "data:image/svg+xml;base64," + b64;
}
</script>

  
const tempEl = document.getElementById("tempF");
const metaEl = document.getElementById("tempMeta");
const rhEl = document.getElementById("rh");
const windEl = document.getElementById("windNow");
const condEl = document.getElementById("condText");
const condIconEl = document.getElementById("condIcon");
const moonTextEl = document.getElementById("moonText");
const moonIconEl = document.getElementById("moonIcon");

function degToCardinal(deg){
  if (deg === null || deg === undefined || Number.isNaN(deg)) return "—";
  const dirs=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
  return dirs[Math.round(deg/22.5)%16];
}

/* WMO weather codes -> simple text */
function wmoToText(code){
  const c = Number(code);
  if(Number.isNaN(c)) return "—";
  if(c===0) return "Clear";
  if(c===1) return "Mainly Clear";
  if(c===2) return "Partly Cloudy";
  if(c===3) return "Overcast";
  if(c===45||c===48) return "Fog";
  if([51,53,55].includes(c)) return "Drizzle";
  if([56,57].includes(c)) return "Freezing Drizzle";
  if(c===61) return "Light Rain";
  if(c===63) return "Rain";
  if(c===65) return "Heavy Rain";
  if([66,67].includes(c)) return "Freezing Rain";
  if(c===71) return "Light Snow";
  if(c===73) return "Snow";
  if(c===75) return "Heavy Snow";
  if([80,81,82].includes(c)) return "Showers";
  if([85,86].includes(c)) return "Snow Showers";
  if(c===95) return "Thunderstorm";
  if([96,99].includes(c)) return "Thunderstorm w/ Hail";
  return "—";
}

/* Use NWS icon set for current conditions (simple mapping) */
function wmoToNwsIcon(code){
  const c = Number(code);
  if(c===0) return "https://api.weather.gov/icons/land/day/skc?size=medium";
  if(c===1) return "https://api.weather.gov/icons/land/day/few?size=medium";
  if(c===2) return "https://api.weather.gov/icons/land/day/sct?size=medium";
  if(c===3) return "https://api.weather.gov/icons/land/day/ovc?size=medium";
  if(c===45||c===48) return "https://api.weather.gov/icons/land/day/fg?size=medium";
  if([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c)) return "https://api.weather.gov/icons/land/day/rain?size=medium";
  if([71,73,75,85,86].includes(c)) return "https://api.weather.gov/icons/land/day/snow?size=medium";
  if([95,96,99].includes(c)) return "https://api.weather.gov/icons/land/day/tsra?size=medium";
  return "https://api.weather.gov/icons/land/day/ovc?size=medium";
}

/* Moon phase (Open-Meteo gives 0..1) + generated SVG icon */
function moonPhaseName(phase){
  const p = Number(phase);
  if(p < 0.03 || p > 0.97) return "New Moon";
  if(p < 0.22) return "Waxing Crescent";
  if(p < 0.28) return "First Quarter";
  if(p < 0.47) return "Waxing Gibbous";
  if(p < 0.53) return "Full Moon";
  if(p < 0.72) return "Waning Gibbous";
  if(p < 0.78) return "Last Quarter";
  return "Waning Crescent";
}
function moonSvgDataUri(phase){
  const p = Number(phase);
  const shift = Math.cos(2*Math.PI*p); // +1 new, -1 full
  const cx = 50 + (shift * 22);
  const svg =
`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <mask id="m">
      <rect width="100" height="100" fill="black"/>
      <circle cx="50" cy="50" r="38" fill="white"/>
      <circle cx="${cx.toFixed(2)}" cy="50" r="38" fill="black"/>
    </mask>
  </defs>
  <circle cx="50" cy="50" r="38" fill="white" opacity="0.18"/>
  <circle cx="50" cy="50" r="38" fill="white" mask="url(#m)"/>
</svg>`;
  return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
}

/* ================= CURRENT: Open-Meteo (fallback to NWS if it fails) ================= */
async function syncCurrent(){
  // helper to show errors clearly
  function fail(msg){
    metaEl.textContent = msg;
  }

  // 1) Try Open-Meteo
  try{
    const url =
      "https://api.open-meteo.com/v1/forecast" +
      `?latitude=${encodeURIComponent(LAT)}` +
      `&longitude=${encodeURIComponent(LON)}` +
      "&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m,weather_code" +
      "&daily=moon_phase" +
      "&temperature_unit=fahrenheit" +
      "&wind_speed_unit=mph" +
      "&timezone=America%2FNew_York";

    const r = await fetch(url,{cache:"no-store"});
    if(!r.ok) throw new Error("Open-Meteo HTTP " + r.status);
    const j = await r.json();
    if(!j.current) throw new Error("Open-Meteo missing current");

    const c = j.current;

    tempEl.textContent = (typeof c.temperature_2m==="number") ? (Math.round(c.temperature_2m)+"°F") : "--°F";
    rhEl.textContent   = (typeof c.relative_humidity_2m==="number") ? Math.round(c.relative_humidity_2m) : "--";
    windEl.textContent = (typeof c.wind_speed_10m==="number" && typeof c.wind_direction_10m==="number")
      ? `${Math.round(c.wind_speed_10m)} mph ${degToCardinal(c.wind_direction_10m)}`
      : "--";

    const condText = wmoToText(c.weather_code);
    condEl.textContent = condText;
    condIconEl.src = wmoToNwsIcon(c.weather_code);

    const phase = j?.daily?.moon_phase?.[0];
    if(typeof phase === "number"){
      moonTextEl.textContent = moonPhaseName(phase);
      moonIconEl.src = moonSvgDataUri(phase);
    }else{
      moonTextEl.textContent = "—";
      moonIconEl.removeAttribute("src");
    }

    metaEl.textContent = "Synced (Open-Meteo)";
    return; // success
  }catch(e){
    // continue to fallback
    fail("Open-Meteo failed: " + (e?.message || "unknown"));
  }

 // 2) Fallback: NWS latest observation + forecast icon
try {
  // ... your existing NWS code that sets temp/rh/wind/cond/icon ...

  // ✅ ALWAYS set moon phase + icon in fallback (no API needed)
  const phase = approxMoonPhase01(new Date());
  moonTextEl.textContent = moonPhaseName(phase);
  moonIconEl.src = moonSvgBase64(phase);

  metaEl.textContent = "Synced (NWS fallback)";
} catch (e) {
  metaEl.textContent = "Weather failed: " + (e?.message || "unknown");
}

    const ob = await fetch(firstStation + "/observations/latest", {cache:"no-store", headers:{Accept:"application/geo+json"}});
    if(!ob.ok) throw new Error("NWS obs HTTP " + ob.status);
    const obs = await ob.json();
    const o = obs.properties || {};

    // temp: Celsius -> F
    const tC = o?.temperature?.value;
    const tF = (typeof tC==="number") ? (tC*9/5+32) : null;
    tempEl.textContent = (tF!==null) ? (Math.round(tF)+"°F") : "--°F";

    const rh = o?.relativeHumidity?.value;
    rhEl.textContent = (typeof rh==="number") ? Math.round(rh) : "--";

    // wind speed is often m/s
    const ws = o?.windSpeed?.value;
    const mph = (typeof ws==="number") ? (ws*2.23694) : null;
    const wd = o?.windDirection?.value;
    windEl.textContent = (mph!==null && typeof wd==="number") ? `${Math.round(mph)} mph ${degToCardinal(wd)}` : "--";

    // description
    condEl.textContent = o?.textDescription || "—";

    // icon: use first forecast period icon
    const fc = await fetch(point.properties.forecast, {cache:"no-store", headers:{Accept:"application/geo+json"}});
    if(fc.ok){
      const forecast = await fc.json();
      const period0 = forecast?.properties?.periods?.[0];
      if(period0?.icon) condIconEl.src = period0.icon;
    }

    // moon: keep previous (unknown from NWS here)
    moonTextEl.textContent = moonTextEl.textContent || "—";
    metaEl.textContent = "Synced (NWS fallback)";
  }catch(e){
    metaEl.textContent = "Weather failed: " + (e?.message || "unknown");
  }
}

/* ================= FORECAST (NWS + gusts) ================= */
const forecastWrap = document.getElementById("forecast3");

async function fetchGeo(url){
  const r = await fetch(url,{cache:"no-store", headers:{Accept:"application/geo+json"}});
  if(!r.ok) throw new Error("HTTP " + r.status);
  return r.json();
}

function dayKeyNY(date){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    year:"numeric",month:"2-digit",day:"2-digit"
  }).format(date);
}

function toMphFrom(uom,value){
  if(value===null||value===undefined||Number.isNaN(value)) return null;
  const s=String(uom||"");
  if(s.includes("knots")) return value*1.15078;
  if(s.includes("m_s-1")) return value*2.23694;
  if(s.includes("mph")) return value;
  return value;
}

function windStr(dir, speed){
  const d = dir ? String(dir).trim() : "";
  const s = speed ? String(speed).trim() : "";
  return (d || s) ? `${d} ${s}`.trim() : "—";
}

async function syncForecast(){
  try{
    const point = await fetchGeo(`https://api.weather.gov/points/${LAT},${LON}`);
    const forecast = await fetchGeo(point.properties.forecast);
    const grid = await fetchGeo(point.properties.forecastGridData);

    const periods = forecast?.properties?.periods || [];
    if(!periods.length) throw new Error("No forecast periods");

    const now = new Date();
    const dayMap = new Map(); // dayKey -> {day,night}
    for(const p of periods){
      const start = new Date(p.startTime);
      if(start < now) continue;

      const k = dayKeyNY(start);
      if(!dayMap.has(k)) dayMap.set(k,{day:null,night:null});
      const entry = dayMap.get(k);

      if(p.isDaytime && !entry.day) entry.day = p;
      if(!p.isDaytime && !entry.night) entry.night = p;

      if(dayMap.size >= 3){
        const first3 = Array.from(dayMap.entries()).slice(0,3);
        if(first3.every(([_,e]) => e.day || e.night)) break;
      }
    }
    const first3 = Array.from(dayMap.entries()).slice(0,3);

    // gusts per day (max)
    const gustSeries = grid?.properties?.windGust?.values || [];
    const gustUom = grid?.properties?.windGust?.uom || "";
    const gustMaxByDay = new Map();

    for(const v of gustSeries){
      const startISO = v.validTime.split("/")[0];
      const start = new Date(startISO);
      if(start < now) continue;

      const k = dayKeyNY(start);
      if(!first3.find(([key])=>key===k)) continue;

      const raw = (typeof v.value==="number") ? v.value : null;
      if(raw===null) continue;

      const mph = toMphFrom(gustUom, raw);
      const prev = gustMaxByDay.get(k);
      gustMaxByDay.set(k, (prev===undefined) ? mph : Math.max(prev, mph));
    }

    forecastWrap.innerHTML = "";
    for(const [k,entry] of first3){
      const d = entry.day;
      const n = entry.night;

      const hi = (d && typeof d.temperature==="number") ? `${d.temperature}°F` : "—";
      const lo = (n && typeof n.temperature==="number") ? `${n.temperature}°F` : "—";
      const icon = (d&&d.icon) || (n&&n.icon) || "";
      const name = (d&&d.name) || (n&&n.name) || "Forecast";

      const popVal = (d?.probabilityOfPrecipitation?.value ?? n?.probabilityOfPrecipitation?.value);
      const popText = (typeof popVal==="number") ? `${Math.round(popVal)}%` : "—";

      const windDir = d?.windDirection ?? n?.windDirection;
      const windSpd = d?.windSpeed ?? n?.windSpeed;

      const gust = gustMaxByDay.get(k);
      const gustText = (typeof gust==="number") ? `${Math.round(gust)} mph` : "—";

      forecastWrap.insertAdjacentHTML("beforeend",`
        <div class="fcard">
          <div class="fday">${name}</div>
          <div class="frow">
            ${icon ? `<img class="ficon" src="${icon}" alt="">` : ``}
            <div class="fmeta">
              <div class="fhilow"><b>Hi:</b> ${hi} &nbsp; <b>Lo:</b> ${lo}</div>
              <div><b>PoP:</b> ${popText}</div>
              <div><b>Wind:</b> ${windStr(windDir, windSpd)}</div>
              <div><b>Gusts:</b> ${gustText}</div>
            </div>
          </div>
        </div>
      `);
    }
  }catch(e){
    forecastWrap.innerHTML = '<div class="small">Forecast failed: '+ (e?.message || "unknown") +'</div>';
  }
}

/* ================= RUN ================= */
syncTime().finally(()=>{
  renderTime();
  setInterval(renderTime, 1000);
  setInterval(syncTime, 10*60*1000);
});

syncCurrent();
setInterval(syncCurrent, 10*60*1000);

syncForecast();
setInterval(syncForecast, 30*60*1000);

})();
</script>

</body>
</html>
