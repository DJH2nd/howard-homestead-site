<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fredonia Hub</title>
<link rel="stylesheet" href="styles.css" />
</head>

<body>
<main class="wrap">

  <div class="brand">The Howard Homestead LLC</div>
  <h1>FREDONIA, PA 16124</h1>

  <!-- ================= TIME + CURRENT CONDITIONS ================= -->
  <section class="panel" aria-label="Time and current conditions">
    <div class="row">

      <div class="block">
        <div class="label">Eastern Standard Time</div>
        <div class="clock" id="clockTime">--:--</div>
        <div class="date" id="clockDate">Loading date…</div>
      </div>

      <div class="block right">
        <div class="label">Current Conditions (16124)</div>
        <div class="temp" id="tempF">--°F</div>

        <div class="small" style="margin-top:6px;">
          Humidity: <span id="rh">--</span>%<br/>
          Wind: <span id="windNow">--</span>
        </div>

        <div class="small" id="tempMeta" style="margin-top:6px;">Syncing…</div>
      </div>

    </div>

    <div class="small status" id="syncStatus">Syncing time…</div>
  </section>

  <!-- ================= FORECAST ================= -->
  <section class="panel" aria-label="3-day forecast">
    <div class="label">3-Day Forecast</div>
    <div class="forecastGrid" id="forecast3">
      <div class="small">Loading forecast…</div>
    </div>
  </section>

</main>

<script>
(function(){

/* ================= CLOCK ================= */
const timeEl = document.getElementById("clockTime");
const dateEl = document.getElementById("clockDate");
const syncEl = document.getElementById("syncStatus");

let offsetMs = 0;
let lastTimeSync = 0;

function formatTime(d){
  // 12-hour time with AM/PM
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    hour:"numeric",
    minute:"2-digit",
    hour12:true
  }).format(d);
}

function formatDate(d){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    weekday:"long",
    year:"numeric",
    month:"long",
    day:"numeric"
  }).format(d);
}

function renderTime(){
  const now = new Date(Date.now() + offsetMs);
  timeEl.textContent = formatTime(now);
  dateEl.textContent = formatDate(now);

  if(lastTimeSync){
    const age = Math.floor((Date.now() - lastTimeSync)/1000);
    syncEl.textContent = "Time synced " + age + "s ago";
  }
}

async function syncTime(){
  try{
    const r = await fetch("https://time.now/developer/api/timezone/America/New_York",{cache:"no-store"});
    const j = await r.json();
    offsetMs = (j.unixtime * 1000) - Date.now();
    lastTimeSync = Date.now();
  }catch{
    offsetMs = 0;
    syncEl.textContent = "Time sync failed (device time)";
  }
}

/* ================= GEO (ZIP -> LAT/LON) ================= */
let cachedLat = null;
let cachedLon = null;

async function geocodeZip(){
  const r = await fetch("https://geocoding-api.open-meteo.com/v1/search?name=16124&count=1&country=US", {cache:"no-store"});
  const j = await r.json();
  const loc = j?.results?.[0];
  if(!loc) throw new Error("No geocode result for 16124");
  cachedLat = loc.latitude;
  cachedLon = loc.longitude;
}

/* ================= CURRENT CONDITIONS (Open-Meteo) ================= */
const tempEl = document.getElementById("tempF");
const tempMetaEl = document.getElementById("tempMeta");
const rhEl = document.getElementById("rh");
const windNowEl = document.getElementById("windNow");

function degToCardinal(deg){
  if (deg === null || deg === undefined || Number.isNaN(deg)) return "—";
  const dirs = ["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
  return dirs[Math.round(deg / 22.5) % 16];
}

async function syncCurrent(){
  try{
    if(cachedLat === null || cachedLon === null) await geocodeZip();

    const url =
      "https://api.open-meteo.com/v1/forecast" +
      `?latitude=${encodeURIComponent(cachedLat)}` +
      `&longitude=${encodeURIComponent(cachedLon)}` +
      "&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m" +
      "&temperature_unit=fahrenheit" +
      "&wind_speed_unit=mph" +
      "&timezone=America%2FNew_York";

    const r = await fetch(url, {cache:"no-store"});
    if(!r.ok) throw new Error("Weather HTTP " + r.status);
    const j = await r.json();

    const t = j?.current?.temperature_2m;
    const rh = j?.current?.relative_humidity_2m;
    const ws = j?.current?.wind_speed_10m;
    const wd = j?.current?.wind_direction_10m;

    tempEl.textContent = (typeof t === "number") ? (Math.round(t) + "°F") : "--°F";
    rhEl.textContent = (typeof rh === "number") ? Math.round(rh) : "--";
    windNowEl.textContent = (typeof ws === "number" && typeof wd === "number")
      ? `${Math.round(ws)} mph ${degToCardinal(wd)}`
      : "--";

    tempMetaEl.textContent = "Synced";
  }catch(e){
    tempMetaEl.textContent = "Current sync failed";
  }
}

/* ================= FORECAST (NWS + GUSTS FROM GRID) ================= */
const forecastWrap = document.getElementById("forecast3");

function windStr(d, s){
  return ((d||"")+" "+(s||"")).trim() || "—";
}

async function fetchJSON(url){
  const r = await fetch(url, {
    cache: "no-store",
    headers: { Accept: "application/geo+json" }
  });
  if(!r.ok) throw new Error(`HTTP ${r.status}`);
  return r.json();
}

function dayKeyNY(date){
  return new Intl.DateTimeFormat("en-US",{
    timeZone:"America/New_York",
    year:"numeric",
    month:"2-digit",
    day:"2-digit"
  }).format(date);
}

function toMphFrom(uom, value){
  // NWS grid often uses knots or m/s. Convert to mph when possible.
  if (value === null || value === undefined || Number.isNaN(value)) return null;

  if (uom.includes("knots")) return value * 1.15078;
  if (uom.includes("m_s-1")) return value * 2.23694;
  if (uom.includes("mph")) return value;
  return value; // unknown, leave as-is
}

async function syncForecast(){
  try{
    if(cachedLat === null || cachedLon === null) await geocodeZip();

    const point = await fetchJSON(`https://api.weather.gov/points/${cachedLat},${cachedLon}`);
    const forecast = await fetchJSON(point.properties.forecast);
    const grid = await fetchJSON(point.properties.forecastGridData);

    const periods = forecast?.properties?.periods || [];
    if(!periods.length) throw new Error("No forecast periods");

    // Pair day/night for Hi/Lo per date
    const now = new Date();
    const days = new Map(); // key -> {day, night}
    for(const p of periods){
      const start = new Date(p.startTime);
      if(start < now) continue;

      const k = dayKeyNY(start);
      if(!days.has(k)) days.set(k,{day:null,night:null});
      const entry = days.get(k);

      if(p.isDaytime && !entry.day) entry.day = p;
      if(!p.isDaytime && !entry.night) entry.night = p;

      // Stop once we have 3 distinct dates and at least one period each
      if(days.size >= 3) {
        const first3 = Array.from(days.values()).slice(0,3);
        const ok = first3.every(x => x.day || x.night);
        if(ok) break;
      }
    }

    const first3 = Array.from(days.entries()).slice(0,3);

    // Gusts from grid: max gust per day, converted to mph when possible
    const gustSeries = grid?.properties?.windGust?.values || [];
    const gustUom = grid?.properties?.windGust?.uom || ""; // e.g. unit:knots
    const gustMaxByDay = new Map();

    for(const v of gustSeries){
      const startISO = v.validTime.split("/")[0];
      const start = new Date(startISO);
      if(start < now) continue;

      const k = dayKeyNY(start);
      // only for our three keys
      if(!first3.find(([key]) => key === k)) continue;

      const raw = (typeof v.value === "number") ? v.value : null;
      if(raw === null) continue;

      const mph = toMphFrom(gustUom, raw);
      const prev = gustMaxByDay.get(k);
      gustMaxByDay.set(k, (prev === undefined) ? mph : Math.max(prev, mph));
    }

    forecastWrap.innerHTML = "";

    for(const [k, entry] of first3){
      const d = entry.day;
      const n = entry.night;

      const hi = (d && typeof d.temperature === "number") ? `${d.temperature}°F` : "—";
      const lo = (n && typeof n.temperature === "number") ? `${n.temperature}°F` : "—";

      const icon = (d && d.icon) || (n && n.icon) || "";
      const name = (d && d.name) || (n && n.name) || "Forecast";

      const popVal = (d?.probabilityOfPrecipitation?.value ?? n?.probabilityOfPrecipitation?.value);
      const popText = (typeof popVal === "number") ? `${Math.round(popVal)}%` : "—";

      const windDir = d?.windDirection ?? n?.windDirection;
      const windSpd = d?.windSpeed ?? n?.windSpeed;

      const gust = gustMaxByDay.get(k);
      const gustText = (typeof gust === "number") ? `${Math.round(gust)} mph` : "—";

      forecastWrap.insertAdjacentHTML("beforeend", `
        <div class="fcard">
          <div class="fday">${name}</div>
          <div class="frow">
            ${icon ? `<img class="ficon" src="${icon}" alt="">` : ``}
            <div class="fmeta">
              <div class="fhilow"><b>Hi:</b> ${hi} &nbsp; <b>Lo:</b> ${lo}</div>
              <div><b>PoP:</b> ${popText}</div>
              <div><b>Wind:</b> ${windStr(windDir, windSpd)}</div>
              <div><b>Gusts:</b> ${gustText}</div>
            </div>
          </div>
        </div>
      `);
    }

  }catch(e){
    forecastWrap.innerHTML = '<div class="small">Forecast load failed.</div>';
  }
}

/* ================= RUN ================= */
syncTime().finally(()=>{
  renderTime();
  setInterval(renderTime, 1000);
  setInterval(syncTime, 10 * 60 * 1000);
});

syncCurrent();
setInterval(syncCurrent, 10 * 60 * 1000);

syncForecast();
setInterval(syncForecast, 30 * 60 * 1000);

})();
</script>

</body>
</html>
